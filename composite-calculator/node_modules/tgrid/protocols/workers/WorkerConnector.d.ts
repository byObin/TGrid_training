/** @module tgrid.protocols.workers */
import { Communicator } from "../../components/Communicator";
import { IConnector } from "../internal/IConnector";
import { IWorkerSystem } from "./internal/IWorkerSystem";
import { Invoke } from "../../components/Invoke";
/**
 * Worker Connector.
 *
 * The `WorkerConnector` is a communicator class, who can create an `Worker` instance and
 * communicate with it using RFC (Remote Function Call), considering the `Worker` as a
 * remote system ({@link WorkerServer}).
 *
 * You can create an `Worker` instance with {@link compile}() or {@link connect}() method.
 * Anyway, after creation of the `Worker` instance, the `Worker` program must open a server
 * using the {@link WorkerServer.open}() method.
 *
 * Note that, after your business, don't forget terminating the worker using {@link close}()
 * or {@link WorkerServer.close}(). If you don't terminate it, then vulnerable memory and
 * communication channel would not be destroyed and it may cause the memory leak.
 *
 * @type Provider Type of features provided for remote system.
 * @author Jeongho Nam - https://github.com/samchon
 */
export declare class WorkerConnector<Headers extends object, Provider extends object | null> extends Communicator<Provider> implements IWorkerSystem, Pick<IConnector<WorkerConnector.State>, "state"> {
    /**
     * @hidden
     */
    private state_;
    /**
     * @hidden
     */
    private worker_?;
    /**
     * Initializer Constructor.
     *
     * @param provider An object providing features for remote system.
     */
    constructor(provider: Provider);
    /**
     * Compile server and connect to there.
     *
     * The {@link compile} method tries compile JS source code, creates `Worker` instance
     * with that code connects to the `Worker`. To complete the compilation and connection,
     * the `Worker` program must open that server using the {@link WorkerServer.open}()
     * method.
     *
     * Note that, after your business has been completed, you've to close the `Worker` using
     * {@link close}() or {@link WorkerServer.close}(). If you don't close that, vulnerable
     * memory usage and communication channel would not be destroyed and it may cause the
     * memory leak.
     *
     * @param content JS Source code to compile.
     * @param headers Headers containing initialization data like activation.
     * @param timeout Milliseconds to wait the worker program to open itself. If omitted, the waiting would be forever.
     */
    compile(content: string, headers: Headers, timeout?: number): Promise<void>;
    /**
     * Connect to server.
     *
     * The {@link connect}() method tries to create an `Worker` instance and connect to the
     * `Worker`. To complete the connection, the `Worker` program must open that server using
     * the {@link WorkerServer.open}() method.
     *
     * Note that, after your business has been completed, you've to close the `Worker` using
     * {@link close}() or {@link WorkerServer.close}(). If you don't close that, vulnerable
     * memory usage and communication channel would not be destroyed and it may cause the
     * memory leak.
     *
     * @param jsFile JS File to be {@link WorkerServer}.
     * @param args Headers containing initialization data like activation.
     * @param timeout Milliseconds to wait the worker program to open itself. If omitted, the waiting would be forever.
     */
    connect<Headers extends object>(jsFile: string, headers: Headers, timeout?: number): Promise<void>;
    /**
     * @hidden
     */
    private _Test_connection;
    /**
     * @hidden
     */
    private _Connect;
    private _Handshake;
    /**
     * @inheritDoc
     */
    close(): Promise<void>;
    /**
     * @inheritDoc
     */
    get state(): WorkerConnector.State;
    /**
     * @hidden
     */
    protected sendData(invoke: Invoke): void;
    /**
     * @hidden
     */
    protected inspectReady(method: string): Error | null;
    /**
     * @hidden
     */
    private _Handle_message;
    /**
     * @hidden
     */
    private _Handle_close;
}
export declare namespace WorkerConnector {
    export import State = IConnector.State;
}
//# sourceMappingURL=WorkerConnector.d.ts.map